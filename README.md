### Compile

```
arduino-cli compile -v --fqbn arduino:avr:uno && arduino-cli upload -v -p /dev/$(ls /dev | grep cu.usb) --fqbn arduino:avr:uno && screen /dev/$(ls /dev | grep tty.usb) 115200
```

### Patches/Modulation

Patch parameters are 8 bit 0..255.
Internal modulation attributes can/could be calculated via 8+8 bit integer/fraction math and scaled to the relevant DAC intervals.

### Doodle

12 bit DAC

-0.75V / Octave => -0.75 V / 12 semitones = -0.0625 V per semitone

0V = F0 = 500Hz

With DAC Vref = 5V

1 bit = 5V / 4096 = 0.001220703125 V

(Voltage unit per octave / number of semitones) / ( DAC Voltage reference / DAC bits available) = bits available per semitone

(0.75 / 12) / (5 / 4096) = 51.2 bits available for tuning / semitone


With DAC Vref = 4V

1 bit = 4V / 4096 = 0.0009765625 V

(Voltage unit per octave / number of semitones) / ( DAC Voltage reference / DAC bits available) = bits available per semitone

(0.75 / 12) / (4 / 4096) = 64 bits available for tuning / semitone

LM337

Vout = Vin * (1 + R2/R1)
-1.25 * (1+510/120)

### DAC

We have a dual 12bit DAC with a 4.096V reference and we want to cover -4V .. +4V (8Vpp) range. The DAC can only output positive voltage, so we need a trick to cover the -4V .. 0V part. Let's set up an OpAmp as an inverting adder.

```
  Vout = -Vin- + Vin+
  Vout = -(DAC_OUTPUT_A) + DAC_OUTPUT_B
```

To get -4V:
1. Set DAC_OUTPUT_A to +4V
2. Set DAC_OUTPUT_B to 0V
3. Vout = -4V + 0V => -4V

To get +4V:
1. Set DAC_OUTPUT_A to 0V
2. Set DAC_OUTPUT_B to +4V
3. Vout = -0V + 4V => 4V

Anything in between is a matter of setting the DAC_OUTPUT_A and DAC_OUTPUT_B so that

  `Vout = -(DAC_OUTPUT_A) + DAC_OUTPUT_B`

From the MP4922 datasheet:

```
Example 6-4: Bipolar Voltage Source With Selectable Gain and Offset

Vref = 5V

R1, R2, R3: 10k

Gain: DACa digital input
Offset: DACb digital input
```

Gain | Offset | Voltage |
-----|--------|---------|
0    | 0      |  0.0
0    | 500    |  0.57
0    | 1000   |  1.15
0    | 1500   |  1.72
0    | 2000   |  2.29
0    | 2500   |  2.86
0    | 3000   |  3.43
0    | 3500   |  4.01
0    | 4000   |  4.58
500  | 0      | -0.54
500  | 500    |  0.0
500  | 1000   |  0.58
500  | 1500   |  1.15
500  | 2000   |  1.72
500  | 2500   |  2.29
500  | 3000   |  2.87
500  | 3500   |  3.44
500  | 4000   |  4.02
1000 | 0      | -1.12
1000 | 500    | -0.54
1000 | 1000   |  0.0
1000 | 1500   |  0.58
1000 | 2000   |  1.15
1000 | 2500   |  1.72
1000 | 3000   |  2.29
1000 | 3500   |  2.87
1000 | 4000   |  3.44
1500 | 0      | -1.68
1500 | 500    | -1.11
1500 | 1000   | -0.54
1500 | 1500   |  0.0
1500 | 2000   |  0.58
1500 | 2500   |  1.15
1500 | 3000   |  1.72
1500 | 3500   |  2.30
1500 | 4000   |  2.88
2000 | 0      | -2.25
2000 | 500    | -1.69
2000 | 1000   | -1.11
2000 | 1500   | -0.54
2000 | 2000   |  0.0
2000 | 2500   |  0.58
2000 | 3000   |  1.15
2000 | 3500   |  1.73
2000 | 4000   |  2.30
2500 | 0      | -2.83
2500 | 500    | -2.26
2500 | 1000   | -1.68
2500 | 1500   | -1.11
2500 | 2000   | -0.54
2500 | 2500   |  0.0
2500 | 3000   |  0.57
2500 | 3500   |  1.15
2500 | 4000   |  1.72
3000 | 0      | -3.39
3000 | 500    | -2.82
3000 | 1000   | -2.25
3000 | 1500   | -1.68
3000 | 2000   | -1.11
3000 | 2500   | -0.54
3000 | 3000   |  0.0
3000 | 3500   |  0.58
3000 | 4000   |  1.15
3500 | 0      | -3.96
3500 | 500    | -3.93
3500 | 1000   | -2.82
3500 | 1500   | -2.25
3500 | 2000   | -1.68
3500 | 2500   | -1.11
3500 | 3000   | -0.54
3500 | 3500   |  0.0
3500 | 4000   |  0.58
4000 | 0      | -4.52
4000 | 500    | -3.96
4000 | 1000   | -3.38
4000 | 1500   | -2.82
4000 | 2000   | -2.25
4000 | 2500   | -1.68
4000 | 3000   | -1.11
4000 | 3500   | -0.54
4000 | 4000   |  0.0

## AS3394

// Voice:
// {
//   0..7000,   // Key CV
//   0..3500,   // Mod Amount
//   0..4000,   // Wave Select
//   0..2000,   // PWM
//   0..3500,   // Mixer Balance
//   0..2000,   // Resonance
//   0..6000,   // Cutoff
//   0..3500    // VCA
// }

## S&H

DAC settling time: 0.0000045s / 4.5 us / 4.5 * 1/1000000
16 000 000 Hz =>   0.0000000625 / tick

(4.5 * ( 1/1000000 )) / ( 1/16000000 ) => 72

```C
__builtin_avr_delay_cycles(72);
```

or

```C
 __asm__ __volatile__("nop");
```

"Every seven milliseconds it must advance each envelope, LFO and glide, and add the latest value into other control signals. ... The voices are controlled by 48 control voltages, which are generated by the DAC, demultiplexers, and sample/holds. Every voice has eight control voltage inputs, and they must all be updated every seven milliseconds."

### To update 6 voices with 8 CVs every 7 milliseconds:

=> (1000 / 7) * 8 = 1,142.8571428571 Hz for IRQ for one voice (each voice has 8 CVs)
1,142.8571428571 * 6 = 6,857.1428571429 Hz for 6 voice

=> (1000 / 7) * 6 * 8 = 6857.142857142857

```C
OCR1A = 2332; // = 16000000 / (1 * 6858.122588941277) - 1 (must be <65536)
```

(2332 + 1)


### To update 6 voices with 8 CVs every 5 milliseconds:

=> (1000/5) * 8 * 6 = 9600.0 Hz

=> (16000000 / (1 * 9600)) - 1 = 1665.6666666666667 = (must be <65536)

```C
OCR1A = 1665; // = 16000000 / (1 * 6900) - 1 (must be <65536)
```

## Connections

### DAC

```
MP4922 pin 1  +5V
MP4922 pin 2  NC
MP4922 pin 3  ~CS / Arduino pin 7
MP4922 pin 4  SCK / Arduino 13 - ICSP/SCK/3
MP4922 pin 5  SDI / Arduino 11 - ICSP/MOSI/4
MP4922 pin 6  NC
MP4922 pin 7  NC

MP4922 pin 8  ~LDAC / GND
MP4922 pin 9  ~SHDN / +5V
MP4922 pin 10 Voutb / 10k / Opamp Non-inverting input
MP4922 pin 11 Vrefb / +5V
MP4922 pin 12 GND
MP4922 pin 13 Vrefa / +5V
MP4922 pin 14 Vouta / 10k / Opamp Inverting input / 4051 pin 3
```

## Voice Param 0..7 4051

```text
4051 pin 1  | out 4  | AS3394 pin 8 PWM
4051 pin 2  | out 6  | AS3394 pin 7 WAVE_SELECT
4051 pin 3  | COMMON | MP4922 pin 14 (DAC_OUTPUT)
4051 pin 4  | out 7  | AS3394 pin 6 MOD_AMT
4051 pin 5  | out 5  | AS3394 pin 2 PITCH
4051 pin 6  | INH    | Voice Select pin D2/D3/D4/D5/D6 on Arduino
4051 pin 7  | Vee    | -6.5V
4051 pin 8  | Vss    | GND

4051 pin 9  | C      | Arduino pin 10
4051 pin 10 | B      | Arduino pin 9
4051 pin 11 | A      | Arduino pin 8
4051 pin 12 | out 3  | AS3394 pin 22 VCA
4051 pin 13 | out 0  | AS3394 pin 20 CUTOFF
4051 pin 14 | out 1  | AS3394 pin 15 RESONANCE
4051 pin 15 | out 2  | AS3394 pin 13 MIXER
4051 pin 16 | Vdd    | +5V
```

## Multiplex order

| Order | CV          | Range        | DAC Values | Misc                                        |
|-------|-------------|--------------|------------|---------------------------------------------|
| 1.    | CUTOFF      | -3 .. +4 V   | 0..7000    | -3V 24kHz => 4 0Hz (3/8V per octave)        |
| 2.    | RESONANCE   |  0 .. +2.5 V | 0..2500    |                                             |
| 3.    | MIXER       | -2 .. +2 V   | 0..4000    | -2 VCA2 1.72 VCA1                           |
| 4.    | VCA         |  0 .. +4.3 V | 0..4200    |                                             |
| 5.    | PWM         |  0 .. +2.2 V | 0..2300    |                                             |
| 6.    | PITCH       | -4 .. +4 V   | 0..8192    | 3/4V per octave                                    |
| 7.    | WAVE_SELECT | -2 .. +4 V   | 0..4500    | -2 SQR -0.3 TRI +1.25 TRI + SAW +2.7 SAW 4V |
| 8.    | MOD_AMOUNT  |  0 .. +4 V   | 0..4000    |                                             |

### Inverse bits

| Voice No | Decimal | Binary    | Inv. Binary | Hex  |
|----------|---------|-----------|-------------|------|
| 1        | 1       | xx000001b | xx11 1110b  | 0x3E |
| 2        | 2       | xx000010b | xx11 1101b  | 0x3D |
| 3        | 4       | xx000100b | xx11 1011b  | 0x3B |
| 4        | 8       | xx001000b | xx11 0111b  | 0x37 |
| 5        | 16      | xx010000b | xx10 1111b  | 0x2F |
| 6        | 32      | xx100000b | xx01 1111b  | 0x1F |
| All off  | 63      | xx000000b | xx11 1111b  | 0x3F |
### simavr

```bash
$ cd /usr/local/Cellar/simavr/HEAD-7c4afd1/examples/board_simduino
$ export SIMAVR_UART_XTERM=1
$ ./simduino
```

```bash
avrdude -p m328p -c arduino -P /dev/ttys005 -U flash:w:atmega328p_dummy_blinky.hex
```


```bash
simavr -v -v  -m atmega328 -f 16000000 ./sketch_nov30a.ino.elf -g
```

```bash
avr-gdb -se ./build/sketch_nov30a.ino.elf
target remote :1234
b loop
c
```

## Generating exponential curves for control values:

Midi controller values usually range from 0..127. Some voice shaping features are better controlled with an "exponential" control. So we should map 0..127 to the control voltage DAC range, which is always starts at 0.

Let generate exponential values between 0...MAX_DAC_VALUE in Y steps:

  `e^(Y/x) = MAX_DAC_VALUE`

```ruby
# Example for exponential cutoff values
max_dac_value = 7000
number_of_steps = 128

numerator = number_of_steps / Math.log(max_dac_value)

(0..number_of_steps).map { |x| Math.exp(x / numerator).to_i }.reverse

# =>
[6532, 6095, 5688, 5308, 4953, 4622, 4313, 4025, 3756, 3505, 3270, 3052, 2848,
 2657, 2480, 2314, 2159, 2015, 1880, 1755, 1637, 1528, 1426, 1330, 1241, 1158,
 1081, 1009, 941, 878, 820, 765, 714, 666, 621, 580, 541, 505, 471, 440, 410,
 383, 357, 333, 311, 290, 271, 253, 236, 220, 205, 191, 179, 167, 155, 145, 135,
 126, 118, 110, 102, 96, 89, 83, 78, 72, 67, 63, 59, 55, 51, 48, 44, 41, 39, 36,
 34, 31, 29, 27, 25, 24, 22, 20, 19, 18, 17, 15, 14, 13, 12, 12, 11, 10, 9, 9, 8,
 7, 7, 6, 6, 6, 5, 5, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1]
```

```ruby
# Example for exponential VCA values
max_dac_value = 4300
number_of_steps = 128

numerator = number_of_steps / Math.log(max_dac_value)

(0..number_of_steps).map { |x| Math.exp(x / numerator).to_i }.reverse

# =>
[4027, 3773, 3534, 3310, 3101, 2905, 2721, 2549, 2387, 2236, 2095, 1962, 1838,
 1722, 1613, 1511, 1415, 1325, 1242, 1163, 1089, 1020, 956, 895, 839, 785, 736,
 689, 646, 605, 566, 531, 497, 465, 436, 408, 382, 358, 336, 314, 294, 276, 258,
 242, 227, 212, 199, 186, 174, 163, 153, 143, 134, 126, 118, 110, 103, 97, 90,
 85, 79, 74, 70, 65, 61, 57, 53, 50, 47, 44, 41, 38, 36, 34, 31, 29, 28, 26, 24,
 23, 21, 20, 18, 17, 16, 15, 14, 13, 12, 11, 11, 10, 9, 9, 8, 8, 7, 7, 6, 6, 5,
 5, 5, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
```

## PWM and WAVE SELECT

From experiments it seems that the PWM needs to be set to 0 when the waveform is other than square, otherwise it distorts the waveform (ie. unexpected behaviour). Though it could be used as a voice shaping feature.


# Autotune

## ATMega328 Analog comparator



https://www.ee-diary.ga/2021/07/how-to-use-arduino-analog-comparator.html

### Important Registers for Analog Comparator

1. ACSR – Analog Comparator Control and Status Register

2. DIDR1 – Digital Input Disable Register 1

3. ADCSRB – ADC Control and Status RegisterB

4. ADCSRA – ADC Control and Status Register A

5. ADMUX – ADC Multiplexer Selection Register


a. Normal operation

In this type of operation of analog comparator, the signals are fed from external source into the AIN1 and AIN0 pins. In this type of operation, only the ACSR and DIDR1 are used.



b. Different source for AIN0 and AIN1

i) If bandgap reference voltage is to be used then ACSR is required. ACSR is also required to monitor the analog comparator output flag and enable/disable power and enable/disable analog comparator interrupt.

ii) If external analog input source(A0 to A7) is to be used for negative input AIN1 then ADCSRA, ADCSRB and ADMUX registers are required.

iii) In all cases if we want to save digital input buffer power then the DIDR1 is required.







https://www.arnabkumardas.com/arduino-tutorial/analog-comparator/

| ACME | ADEN | MUX2…0 | Analog Comparator Negative Input |
|------|------|--------|----------------------------------|
|   1  |   0  |   101  | ADC5                             |

https://www.ee-diary.ga/2021/07/arduino-analog-comparator-with-interrupt.html

```C
uint8_t old_acsr;
void setup () {
  DIDR1 |= (1 << AIN0D) | // Disable Digital Inputs at AIN0 and AIN1
           (1 << AIN1D);

  ADCSRA &= ~(1 << ADEN); // Disable the ADC
  ADCSRB |= (1 << ACME);  //Set ACME bit in ADCSRB to use external analog input
                          // at AIN1 -ve input
  ADMUX = 0x101;          //select A5 as input
  old_acsr = ACSR;
  ACSR = (0 << ACD)   |   // Analog Comparator: Enabled
         (1 << ACBG)  |   // Set ACBG to use bandgap reference for +ve input
         (0 << ACO)   |   // Analog Comparator Output: OFF
         (1 << ACI)   |   // Analog Comparator Interrupt Flag:
                          // Clear Pending Interrupt by  setting the bit
         (1 << ACIE)  |   // Analog Comparator Interrupt: Enable
         (0 << ACIC)  |   // Analog Comparator Input Capture: Disabled
         (0 << ACIS1) |   // Analog Comparator Interrupt Mode:
         (0 << ACIS0);    // Comparator Interrupt on Output Toggle

  sei();
}

void loop() {
}

ISR(ANALOG_COMP_vect)
{
  if(ACSR & (1<<ACO))
    PORTD |= (1<<PD4);
  else
    PORTD &= ~(1<<PD4);
}
```


// https://openenergymonitor.github.io/forum-archive/node/2446.html
// boolean FlagZeroDetec;
// // Analog Comparator
// DIDR1 = 0b00000011;       // AIN1D..AIN0D: AIN1, AIN0 Digital Input Disable, saves power
// ACSR = (0<<ACD) |     // Analog Comparator: Enabled
//        (0<<ACBG) |    // Analog Comparator Bandgap Select: AIN0 is the positive input of comparator
//        (0<<ACO) |     // Analog Comparator Output: Off
//        (1UL<<ACI)|    // Analog Comparator Interrupt Flag : Clear Pending Interrupt
//        (1UL<<ACIE)|   // Analog Comparator Interrupt Enable
//        //(1UL<<ACIC)|   // Analog Comparator Input Capture Enable on Timer/Counter1
//        (0UL<<ACIS1)|  // --- Comparator Interrupt on Output Toggle.
//        (0UL<<ACIS0);  // -/

// ISR(ANALOG_COMP_vect)
// {
//   FlagZeroDetec=true;
//   bitClear(ACSR,ACIE);
// }
// void loop()
// {
//     if(FlagZeroDetec == true) {
//       digitalWrite(9,1);
//       FlagZeroDetec = false;
//       delay(1); // added by MR
//       bitSet(ACSR,ACIE); // added by MR
//     }
//     digitalWrite(9,0);
// }


for(current_autotune_octave = 0; current_autotune_octave < 6; current_autotune_octave++) {
  for(int i = 0; i < NUMBER_OF_VOICES; i ++) {
    voicess[i].dacValues = current_autotune_octave * CV_AUTOTUNE_OCTAVE;
  }
  for(int i = 0; i < NUMBER_OF_VOICES; i ++) {
    // Measure autotune errors
    // voicess[i].autotune_errors[0] = 0;
  }
}

